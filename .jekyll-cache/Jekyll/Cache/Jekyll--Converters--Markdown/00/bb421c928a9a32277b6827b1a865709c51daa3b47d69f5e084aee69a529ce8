I"Z
<p>Another list of things I learned in the past 2023.
<!--more--></p>
<h3 id="python-parallelism">Python parallelism</h3>

<table>
  <thead>
    <tr>
      <th>type</th>
      <th>memory</th>
      <th>start</th>
      <th>run</th>
      <th>kernel</th>
      <th>obs</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>coroutines</td>
      <td>very low</td>
      <td>very fast</td>
      <td>slow</td>
      <td>main thread</td>
      <td>Cooperative concurrency, non-preemptive multitasking. Using yield in <em>generators</em> or <em>async/await</em> (or greenlets?) tasks pass control between themselves. Could be run with threads.</td>
    </tr>
    <tr>
      <td>threads</td>
      <td>low</td>
      <td>fast</td>
      <td>slow</td>
      <td>kernel threads</td>
      <td>Preemptive concurrency. Due to GIL, not real multitasking (parallelism). Same memory context. Like coroutines useful only for non-blocking I/O (network or disk) or non-blocking external function calls.</td>
    </tr>
    <tr>
      <td>subinterpreters</td>
      <td>large</td>
      <td>slow</td>
      <td>fast</td>
      <td>kernel threads</td>
      <td>A full interpreter with a separate GIL. Capable of true multitasking. Communicates through serialized (pickle) messages (objects). In principle capable to access shared memory. Very new, maybe preparing a no-GIL future.</td>
    </tr>
    <tr>
      <td>processes</td>
      <td>very large</td>
      <td>very slow</td>
      <td>fast</td>
      <td>processes</td>
      <td>Traditional multitasking solution for CPU bound tasks.</td>
    </tr>
  </tbody>
</table>

<p>As a comparison <em>virtual threads</em> for Java are the equivalent of coroutines in Java. They allow for low memory, 
fast to spin-up  <em>preemptive</em> multitasking. They are transparently assigned by JVM to pre-spun kernel threads.</p>

<h3 id="what-is-the-deal-with-cassandra">What is the deal with Cassandra?</h3>

<p>Simply put best distributed DB. Multipurpose, very scalable, very resilient, open source, SQL compatible, high read and write.
There is a price though.</p>

<ol>
  <li>No strict ACID. One can tune for the required balance between availability (AP) and consistency (CP).</li>
  <li>It is not relational. The columnar structure does not allow for foreign keys or joins, and many SQL queries are impossible or very slow.</li>
  <li>Data scheme must be carefully chosen (using denormalization and duplications) in order to allow for the needed usage (queries).</li>
</ol>

<h3 id="number-of-ancestors">Number of ancestors</h3>

<p>If one goes $n$ generations in the past, one has, in principle, $2^n$ ancestors</p>
:ET